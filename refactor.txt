Lifecycle walkthrough (current state)
Đăng ký (sign up)
Luồng: AuthDialog.vue → useAuthStore().register() → POST /auth/register với name/email/password/recaptcha. Không tự đăng nhập sau khi tạo.
Dữ liệu/response: gửi JSON cơ bản, trả về response.data không được chuẩn hóa; client không lưu token hay user.
Đánh giá: đơn giản, dễ hiểu. Tuy nhiên chưa có validation phía client, không xử lý lỗi đặc thù (email trùng, password chính sách), và không liên kết sẵn với bước đăng nhập → UX không mượt.
Đăng nhập (sign in)
Luồng: form gọi useAuthStore().login() → POST /auth/login.
Dữ liệu trả về: extractAuthPayload() nhận access_token, refresh_token, expires_in, refresh_expires_at, user, device_name.
Xử lý:
Access token và thời gian hết hạn lưu vào sessionStorage.
Refresh token + device name lưu localStorage.
User lưu sessionStorage.
Đánh giá: có phân tách session/local storage và đồng bộ trạng thái Pinia. Tuy vậy:
Thiếu kiểm tra expires_in âm hoặc thiếu.
deviceName lưu nhưng không có tính năng sử dụng rộng, dễ rò rỉ (localStorage).
Không chống brute force (captchas, throttling) ở phía client.
Quản lý token (JWT/refresh)
Token storage: sessionStorage cho access, localStorage cho refresh.
Tiện ích: tokenStorage cung cấp get/set, hasValidToken(), isTokenExpired() (buffer 60s).
Vấn đề chính:
Refresh token lưu localStorage ⇒ dễ bị XSS trích xuất (OWASP đề xuất cookie httpOnly).
setRefreshToken bỏ qua hạn sử dụng; không có check refreshExpiresAt.
clearAll() xoá cả session/local nhưng không có rotation theo mỗi refresh (phụ thuộc backend).
Xác thực request (axios middleware + router guard)
Axios boot:
Request interceptor chèn Authorization: Bearer.
Response interceptor tự refresh khi 401 (trừ các endpoint auth).
Hàng đợi failedQueue xử lý request song song trong lúc refresh.
Nếu refresh fail ⇒ authStore.clearAuth().
Router guard:
Kiểm tra meta.requiresAuth.
Ưu tiên access token hợp lệ; nếu hết hạn mà còn refresh token ⇒ gọi authStore.refreshToken() và loadProfile().
Redirect về home?login=1 khi thất bại.
Đánh giá: logic khá đầy đủ, handle concurrency tốt. Điểm yếu:
Guard chỉ kiểm tra phía client, không có phân quyền chi tiết.
Khi refresh thất bại, router redirect nhưng axios interceptor trước đó đã xoá token ⇒ trạng thái inconsistent trong UI (không hiển thị thông báo rõ).
Thiếu cơ chế back-off hoặc giới hạn số lần refresh liên tục.
Gia hạn token (refresh)
Store: refreshToken() check đang refresh, dùng this.refreshPromise để share promise.
Request: POST /auth/refresh-token với refresh_token.
Sau nhận: cập nhật access + refresh token, user (nếu có). Nếu lỗi 401 ⇒ logout(true).
Đánh giá: concurrency control tốt. Thiếu kiểm tra refreshExpiresAt (client có thể chủ động logout khi quá hạn). Không thực hiện rotation refresh token nếu backend không trả token mới.
Đăng xuất (logout)
Luồng: logout() gọi API /auth/logout với refresh token nếu không silent.
Cleanup: clearAuth() xoá mọi storage, reset state.
Đánh giá: luôn dọn client, kể cả khi server lỗi. Nhưng:
Không bắt refresh token thiếu (silent skip).
Không xử lý revoke toàn bộ phiên được lưu server-side—phụ thuộc backend.
Không có confirm/feedback UI rõ.
So sánh best practices (OAuth2, JWT, OWASP ASVS)
Hạng mục	Điểm mạnh	Khoảng cách so với best practice
Lưu trữ token	Session cho access token (giảm XSS)	Refresh token vẫn ở localStorage ⇒ trái với khuyến nghị OWASP (nên để httpOnly cookie)
Hết hạn token	Access token có timestamp, buffer 60s	Refresh token không kiểm tra hạn, không rotate bắt buộc
Refresh flow	Hỗ trợ song song, queue request	Không giới hạn số lần refresh, chưa log/metrics cho abuse
Đăng nhập	Xử lý response linh động, lưu user	Thiếu MFA/2FA hooks, chưa chuẩn hoá DTO, chưa có error mapping
Đăng ký	Có reCAPTCHA	Thiếu password policy client-side, chưa auto login/verify email
Middleware	Axios & router guard tích hợp	Không phân quyền, không handle 403/permission, thiếu audit logs
Đăng xuất	Có revoke API call	Không đảm bảo server revoke thành công, không hiển thị lỗi, thiếu event broadcast (đa tab)
Điểm yếu/ rủi ro bảo mật tiềm ẩn
Refresh token trong localStorage ⇒ dễ bị đánh cắp qua XSS.
Không kiểm tra hạn refresh token ⇒ client tiếp tục gọi refresh vô nghĩa, gây spam.
Thiếu rotation refresh token cưỡng bức ⇒ nếu token bị lộ ở bước trước, attacker vẫn dùng được.
Không có CSRF protection khi dùng cookie (nếu chuyển sang cookie mà không kèm SameSite/CSRF token).
Guard chỉ xử lý auth cơ bản ⇒ URL nhạy cảm chỉ cần bypass guard (ví dụ deep-link) vẫn phải dựa backend.
Thiếu xử lý lỗi thống nhất ⇒ UI ít feedback, dễ khiến user refresh nhiều lần.
Logout không revoke thiết bị khác (trừ khi gọi API riêng), token có thể vẫn hợp lệ server-side.
Gợi ý refactor (theo kiến trúc Quasar)
Tách lớp service/controller:
src/services/authService.js: wraps axios calls.
src/composables/useAuth() hoặc stores/auth chỉ giữ state và gọi service.
boot/auth-guard.js: đăng ký router guard, inject dependency.
Token handling an toàn:
Chuyển refresh token về httpOnly, secure cookie (phối hợp backend).
Access token vẫn trong memory/session. Tạo TokenManager thay vì trực tiếp dùng sessionStorage.
Thêm kiểm tra refreshExpiresAt, auto logout khi sắp hết hạn.
Mở rộng cho OAuth/SSO:
Chuẩn hoá DTO auth (AuthCredentials, AuthTokens, AuthUser).
Định nghĩa AuthProvider interface (native, Google, Facebook…) và map vào store.
UX/error:
Tạo AuthErrorMapper để chuyển mã lỗi API thành thông báo UI.
Broadcast logout qua window.postMessage hoặc storage event để đồng bộ tabs.
Logging & metrics:
Hook axios để emit event (via Pinia plugin/EventBus) cho DevTools/monitoring.
Testing:
Viết unit test cho tokenStorage, authStore.refreshToken() (mock axios).
Viết E2E scenario Cypress: login, refresh expiry, logout.
Code mẫu theo hướng xử lý phổ biến
Backend (Node.js + Express, JWT + Refresh cookie)

// auth.controller.tsimport { Request, Response } from 'express'import { AuthService } from './auth.service'const authService = new AuthService()export async function signIn(req: Request, res: Response) {  const { email, password } = req.body  const { accessToken, refreshToken, refreshTokenMeta, user } =    await authService.signIn(email, password)  res    .cookie('refresh_token', refreshToken, {      httpOnly: true,      sameSite: 'strict',      secure: process.env.NODE_ENV === 'production',      maxAge: refreshTokenMeta.expiresInMs,    })    .status(200)    .json({      access_token: accessToken.token,      expires_in: accessToken.expiresIn,      user,    })}export async function refresh(req: Request, res: Response) {  const cookieToken = req.cookies['refresh_token']  const { accessToken, newRefreshToken, refreshTokenMeta } =    await authService.rotateRefresh(cookieToken)  res    .cookie('refresh_token', newRefreshToken, {      httpOnly: true,      sameSite: 'strict',      secure: process.env.NODE_ENV === 'production',      maxAge: refreshTokenMeta.expiresInMs,    })    .status(200)    .json({      access_token: accessToken.token,      expires_in: accessToken.expiresIn,    })}export async function signOut(req: Request, res: Response) {  const cookieToken = req.cookies['refresh_token']  await authService.revokeRefresh(cookieToken)  res    .clearCookie('refresh_token', { httpOnly: true, sameSite: 'strict', secure: process.env.NODE_ENV === 'production' })    .status(204)    .send()}

// auth.service.tsimport argon2 from 'argon2'import jwt from 'jsonwebtoken'import { RefreshStore } from './refresh.store'import { UsersRepository } from './users.repo'export class AuthService {  private refreshStore = new RefreshStore()  private usersRepo = new UsersRepository()  async signIn(email: string, password: string) {    const user = await this.usersRepo.findByEmail(email)    if (!user || !(await argon2.verify(user.passwordHash, password))) {      throw new Error('INVALID_CREDENTIALS')    }    const accessToken = this.issueAccessToken(user.id)    const { token: refreshToken, meta } = await this.refreshStore.issue(user.id, 'web')    return {      user: { id: user.id, email: user.email, role: user.role },      accessToken,      refreshToken,      refreshTokenMeta: meta,    }  }  async rotateRefresh(refreshToken: string) {    const session = await this.refreshStore.verifyAndRotate(refreshToken)    const accessToken = this.issueAccessToken(session.userId)    const rotated = await this.refreshStore.issue(session.userId, session.device, session.id)    return {      accessToken,      newRefreshToken: rotated.token,      refreshTokenMeta: rotated.meta,    }  }  async revokeRefresh(refreshToken?: string) {    if (refreshToken) {      await this.refreshStore.revoke(refreshToken)    }  }  private issueAccessToken(userId: string) {    const expiresIn = 15 * 60    return {      token: jwt.sign({ sub: userId }, process.env.JWT_SECRET!, { expiresIn }),      expiresIn,    }  }}

// auth.middleware.tsimport { Request, Response, NextFunction } from 'express'import jwt from 'jsonwebtoken'export function authenticate() {  return (req: Request, res: Response, next: NextFunction) => {    const header = req.headers.authorization    if (!header?.startsWith('Bearer ')) {      return res.status(401).json({ message: 'Unauthorized' })    }    try {      const token = header.slice(7)      const payload = jwt.verify(token, process.env.JWT_SECRET!)      req.user = { id: (payload as any).sub }      return next()    } catch (error) {      return res.status(401).json({ message: 'Token invalid or expired' })    }  }}

// refresh.store.ts (pseudo)import { randomBytes } from 'crypto'import { addSeconds } from 'date-fns'export class RefreshStore {  private store = new Map<string, { userId: string, device: string, expiresAt: Date, parent?: string }>()  async issue(userId: string, device: string, parentId?: string) {    if (parentId) this.store.delete(parentId) // rotation: revoke old    const token = randomBytes(64).toString('hex')    const expiresAt = addSeconds(new Date(), 60 * 60 * 24 * 30)    this.store.set(token, { userId, device, expiresAt, parent: parentId })    return { token, meta: { expiresInMs: expiresAt.getTime() - Date.now() } }  }  async verifyAndRotate(token: string) {    const session = this.store.get(token)    if (!session || session.expiresAt < new Date()) {      throw new Error('REFRESH_INVALID')    }    this.store.delete(token)    return session  }  async revoke(token: string) {    this.store.delete(token)  }}
Frontend Quasar (gợi ý composable + axios)

// src/services/httpClient.jsimport axios from 'axios'export const http = axios.create({  baseURL: process.env.API_BASE_URL,  withCredentials: true, // cookie chứa refresh token})http.interceptors.request.use((cfg) => {  const accessToken = sessionStorage.getItem('access_token')  if (accessToken) cfg.headers.Authorization = `Bearer ${accessToken}`  return cfg})

// src/services/authService.jsimport { http } from './httpClient'export async function signIn(credentials) {  const { data } = await http.post('/auth/login', credentials)  sessionStorage.setItem('access_token', data.access_token)  sessionStorage.setItem('access_expires_at', String(Date.now() + data.expires_in * 1000))  return data.user}export async function refreshAccessToken() {  const { data } = await http.post('/auth/refresh')  sessionStorage.setItem('access_token', data.access_token)  sessionStorage.setItem('access_expires_at', String(Date.now() + data.expires_in * 1000))  return data.access_token}export async function signOut() {  await http.post('/auth/logout')  sessionStorage.removeItem('access_token')  sessionStorage.removeItem('access_expires_at')}

// src/composables/useAuth.jsimport { ref, computed } from 'vue'import { signIn, signOut, refreshAccessToken } from 'src/services/authService'import { useQuasar } from 'quasar'const user = ref(null)const isRefreshing = ref(false)export function useAuth() {  const $q = useQuasar()  const isAuthenticated = computed(() => !!user.value && hasValidAccess())  async function login(payload) {    user.value = await signIn(payload)  }  async function refresh() {    if (isRefreshing.value) return    isRefreshing.value = true    try {      await refreshAccessToken()    } finally {      isRefreshing.value = false    }  }  async function logout() {    await signOut()    user.value = null    $q.notify({ type: 'positive', message: 'Đã đăng xuất' })  }  return { user, isAuthenticated, login, logout, refresh }}function hasValidAccess() {  const exp = Number(sessionStorage.getItem('access_expires_at') || 0)  return Date.now() + 60_000 < exp}

// src/router/guards/authGuard.jsimport { useAuth } from 'src/composables/useAuth'export const authGuard = async (to, from, next) => {  const { isAuthenticated, refresh } = useAuth()  if (!to.meta.requiresAuth) return next()  if (isAuthenticated.value) return next()  try {    await refresh()    return isAuthenticated.value ? next() : redirectToLogin(to, next)  } catch {    return redirectToLogin(to, next)  }}function redirectToLogin(to, next) {  return next({ name: 'login', query: { redirect: to.fullPath } })}
Bản kiểm toán vòng đời auth
Điểm mạnh
Có hệ thống lưu trữ token rõ ràng, tách access/refresh.
Axios boot + guard xử lý hầu hết edge case 401, queue đồng bộ tốt.
Store Pinia tập trung, dễ tái sử dụng giữa component/modals.
Đã tính tới workflows phụ (quên mật khẩu, quản lý thiết bị).
Điểm yếu
Refresh token trong localStorage, không rotation, thiếu kiểm tra hạn.
Thiếu phân lớp service rõ ràng khiến store ôm cả logic HTTP.
Guard/axios chưa chuẩn hoá xử lý lỗi và phân quyền theo vai trò.
Chưa có chiến lược đồng bộ đa tab hoặc logging cho auditing.
Logout không chắc chắn revoke server-side, chưa có fallback UI.
Gợi ý refactor
Di chuyển token nhạy cảm về httpOnly cookie, giữ access token trong session/memory; thêm CSRF token.
Tách authService + useAuth composable, cho store tập trung quản lý state và caching.
Thêm refresh scheduler: khi expiresAt < 2 phút, tự refresh + xử lý hết hạn refresh => logout với thông báo.
Chuẩn hoá DTO & error mapper, gắn với i18n + notify Quasar.
Phân quyền: mở rộng guard để kiểm tra to.meta.roles hoặc permissions.
Quan sát/giám sát: emit events để log ra Sentry hoặc console.
Code mẫu theo hướng phổ biến
Backend Express với auth.service quản lý JWT, refresh store (Redis/bộ nhớ) và middleware xác thực.
Frontend Quasar authService + useAuth, axios interceptor nhẹ, guard đơn giản, sessionStorage chỉ giữ access token.
Quality gates
Build: not run (analysis only).
Lint: not run.
Tests: not run.
(Chưa cần vì không chỉnh code; sẵn sàng chạy nếu triển khai refactor.)
Requirements coverage
Sign-up flow ✅ · Sign-in flow ✅ · Token management ✅ · Auth guard ✅ · Token refresh ✅ · Logout ✅ · Best-practice review ✅ · Refactor proposal ✅ · Sample code ✅

Next steps
Đồng bộ với backend để chuyển refresh token sang cookie httpOnly và hỗ trợ rotation.
Triển khai authService/composable mới + unit test cho tokenStorage.
Thử nghiệm E2E (Cypress/Playwright) cho full auth lifecycle.